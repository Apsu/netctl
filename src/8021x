# Uses wpa_supplicant to check for association to a network
# wpa_check interface [timeout]
wpa_check()
{
    local timeout=0 INTERFACE="$1" TIMEOUT="${2:-15}"

    while [[ $timeout -lt "$TIMEOUT" ]]; do
        ( # Sometimes wpa_supplicant isn't ready so silence errors for 2s only to avoid hiding real errors
        if [[ $timeout -lt 2 ]]; then
            eval $(wpa_cli -i "$INTERFACE" status 2> /dev/null | fgrep "wpa_state=")
        else
            eval $(wpa_cli -i "$INTERFACE" status | fgrep "wpa_state=")
        fi
        [[ "$wpa_state" = "COMPLETED" ]]
        ) && return 0
        sleep 1
        let timeout++
    done
    echo "$wpa_state"
    # wpa_cli -i "$INTERFACE" terminate >/dev/null 2>&1   # callers sometimes called stop_wpa, which does more but seems redundant
                                                        # termination should either be handled properly here, or by callers
    stop_wpa "$INTERFACE"
    return 1
}

start_wpa()
{
    local INTERFACE="$1" WPA_CONF="$2"
    shift 2
    local WPA_OPTS="$*"

    wpa_supplicant -B -P "/var/run/wpa_supplicant_${INTERFACE}.pid" -i "$INTERFACE" -c "$WPA_CONF" $WPA_OPTS
    sleep 1

    if [[ ! -f "/var/run/wpa_supplicant_${INTERFACE}.pid" ]]; then
        return 1
    fi
}

stop_wpa()
{
    wpa_cli -i "$1" terminate &> /dev/null
    sleep 1         # JP: need this else the file tends to disappear after [[ -f ... ]] but before cat...
                    # see <http://bbs.archlinux.org/viewtopic.php?pid=515667#p515667>
    if [[ -f "/var/run/wpa_supplicant_$1.pid" ]]; then
        kill "$(cat "/var/run/wpa_supplicant_$1.pid")" &>/dev/null &
    fi
}

# vim: ft=sh ts=4 et sw=4:
