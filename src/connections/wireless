#! /bin/bash
. /usr/lib/network/network






wireless_up() {

    load_profile "$1"

    . "$SUBR_DIR/8021x"
    . "$SUBR_DIR/wireless"

    # Enable rfkill if necessary, or fail if it is hardware
    if [[ -n "$RFKILL" ]]; then
        local state=$(get_rf_state "$INTERFACE") || return 1
        if [[ "$state" != "up" ]]; then
            if [[ "$RFKILL" == "soft" ]]; then
                set_rf_state "$INTERFACE" up
                sleep 1
            else
                report_fail "radio is disabled on $INTERFACE"
                return 1
            fi
        fi
    fi

    # Check if interface exists
    is_interface $INTERFACE || report_fail "interface $INTERFACE does not exist"

    # Kill any lingering wpa_supplicants.
    report_debug wireless_up stop_wpa "$INTERFACE"
    stop_wpa "$INTERFACE"

    # Most drivers (mac80211) need mode set before device is brought up
    if [[ $(iwgetid -sm "$INTERFACE") -ne Managed ]]; then
        report_debug wireless_up iwconfig "$INTERFACE" mode managed
        iwconfig "$INTERFACE" mode managed
    fi

    report_debug wireless_up ifup
    bring_interface up "$INTERFACE" || return 1
    
    quirk prescan && iwlist "$INTERFACE" scan &> /dev/null # bcm43xx
    quirk preessid && eval "iwconfig \"$INTERFACE\" mode managed essid \"$ESSID\"" # ipw3945

    # Scan for network's existence first
    if checkyesno "${SCAN:-no}"; then
        report_debug wireless_up scanning
        local OLDESSID="$ESSID"
        if [[ -n "$AP" ]]; then
            ESSID=$(find_ap "$INTERFACE" "$AP")
        else
            ESSID=$(find_essid "$INTERFACE" "$ESSID")
        fi
        if [[ $? -gt 0 ]]; then
            report_fail "Wireless network \"$OLDESSID\" not present."
            return 1
        fi
    fi

    # Manually set iwconfig options
    if [[ -n "$IWCONFIG" ]]; then
        report_debug wireless_up iwconfig "$INTERFACE" $IWCONFIG
        iwconfig "$INTERFACE" $IWCONFIG
    fi

    # Set to 'none' if not set
    [[ -z "$SECURITY" ]] && SECURITY="none"

    case "$SECURITY" in
    wep-old|none-old)
        # 'none' uses iwconfig like wep. Use sane default if WEP_OPTS=""
        if [[ -z "$WEP_OPTS" ]]; then
            if [[ "$SECURITY" = "wep" ]]; then
                if [[ -n "$AP" ]]; then
                    WEP_OPTS="ap \"$AP\" key $KEY"          # JP: formerly I had "...key open $KEY"; is it correct to omit the 'open'?
                else
                    WEP_OPTS="essid \"$ESSID\" key $KEY"          # JP: formerly I had "...key open $KEY"; is it correct to omit the 'open'?
                fi
            elif [[ "$SECURITY" = "none" ]]; then
                if [[ -n "$AP" ]]; then
                    WEP_OPTS="ap \"$AP\""
                else
                    WEP_OPTS="essid \"$ESSID\""
                fi
            fi
        fi

        if quirk "predown"; then # madwifi FS#10585
            # ignore quirk nodown---is that appropriate?
            # this adds a flush call as well---is that appropriate?
            bring_interface forcedown "$INTERFACE"
        fi

        report_debug wireless_up iwconfig "$INTERFACE" $WEP_OPTS
        # JP: I don't understand why this needs to be an eval. What's wrong with just:
        # iwconfig "$INTERFACE" $WEP_OPTS
        if ! eval "iwconfig \"$INTERFACE\" $WEP_OPTS"; then
            report_fail "Could not set wireless configuration."
            return 1
        fi

        if quirk "predown"; then # madwifi FS#10585
           bring_interface up "$INTERFACE"
        fi

        report_debug ethernet_up wep_check
        if ! wep_check "$INTERFACE" "$TIMEOUT"; then
            report_fail "WEP Association Failed"
            return 1
        fi
        ;;
    wep)
        WPA_CONF="$(make_wpa_config $1)"
        if [[ ${KEY:0:2} == "s:" ]]; then # TODO: does wpa_supplicant handle this as expected? 
            echo -e "network={ \nssid=\"$ESSID\" \nkey_mgmt=NONE \nwep_key0=\"${KEY:2}\" \nwep_tx_keyidx=0 \n}" >> "$WPA_CONF"
        else
            echo -e "network={ \nssid=\"$ESSID\" \nkey_mgmt=NONE \nwep_key0=$KEY \nwep_tx_keyidx=0 \n}" >> "$WPA_CONF"
        fi
        ;;
    none)
        WPA_CONF="$(make_wpa_config $1)"
        echo -e "network={ \nssid=\"$ESSID\" \nkey_mgmt=NONE \n}" >> "$WPA_CONF"
        ;;
    wpa)
        # Quirk for broken drivers... http://bbs.archlinux.org/viewtopic.php?id=36384
        if quirk "wpaessid"; then
            if [[ -n "$AP" ]]; then
               # JP: Since I don't undertand why the else block below is an eval, I'm not sure
               # if this command also needs to be eval'd
               iwconfig "$INTERFACE" ap "$AP"
            else
                # JP: I don't understand why this needs to be an eval. What's wrong with just:
                # iwconfig "$INTERFACE" essid "$ESSID"
               eval "iwconfig \"$INTERFACE\" essid \"$ESSID\""
            fi
        fi

        WPA_CONF="$(make_wpa_config $1)"
        # Generate configuration
        if [[ "${#KEY}" -eq 64 ]]; then
            echo -e "network={ \nssid=\"$ESSID\" \npsk=$KEY \n}">> "$WPA_CONF"
        elif ! echo "$KEY" | wpa_passphrase "$ESSID" >> "$WPA_CONF"; then
            report_fail "Configuration generation failed."
            cat "$WPA_CONF" >&2
            return 1
        fi
        ;;
    wpa-config)
        . "$SUBR_DIR/8021x"
        [[ -z "$WPA_CONF" ]] && WPA_CONF="/etc/wpa_supplicant.conf" # defaults
        ;;
    wpa-configsection)
        . "$SUBR_DIR/8021x"
        WPA_CONF="$(make_wpa_config $1)" 
        echo -e "network={ \n$CONFIGSECTION \n}">> "$WPA_CONF"
        ;;
    esac
    
    if  [[ ${SECURITY:(-4)} != "-old" ]]; then
        [[ -z "$WPA_DRIVER" ]] && WPA_DRIVER="wext"
        report_debug wireless_up start_wpa "$INTERFACE" "$WPA_CONF" "$WPA_DRIVER" "$WPA_OPTS"
        if ! start_wpa "$INTERFACE" "$WPA_CONF" "$WPA_DRIVER" "$WPA_OPTS"; then
            report_fail "wpa_supplicant did not start, possible configuration error"
            return 1
        fi
        report_debug wireless_up wpa_check
        if ! wpa_check "$INTERFACE" "$TIMEOUT"; then
            report_fail "WPA Authentication/Association Failed"
            return 1
        fi        
    fi

    if ! $CONN_DIR/ethernet up "$1"; then
        wireless_down "$1" YES
        return 1
    fi
}

# wireless_down PROFILE [ LEAVE ifconfig up? default no ]
wireless_down() {
    local PROFILE="$1" NOETHERNETDOWN="$2"
    load_profile "$PROFILE"
    . "$SUBR_DIR/8021x"
    if ! checkyesno "$NOETHERNETDOWN"; then
        "$CONN_DIR/ethernet" down "$PROFILE"
    fi
    report_debug wireless_down stop_wpa "$INTERFACE"
    stop_wpa "$INTERFACE"
    [[ "$SECURITY" == "wpa" ]] && rm -rf "${TMPDIR:-/tmp}/wpa.${PROFILE// /}" # remove tmp wpa config
    report_debug wireless_down iwconfig "$INTERFACE" essid off key off
    iwconfig "$INTERFACE" essid off key off &> /dev/null
    # respects quirk nodown---is that appropriate?
    # wasn't this already called in ethernet_down? but does the call there respect quirk nodown?
    # this adds a flush call as well---is that appropriate?
    bring_interface down "$INTERFACE"

    # Handle wireless kill switches
    # Any reason why a hardware switch should be considered on interface down?
    if [[ "$RFKILL" == "soft" ]]; then
        . "$SUBR_DIR/wireless"
        set_rf_state "$INTERFACE" down || return 1
    fi
}

# Returns status of profile - is it still functional?
wireless_status() {
    load_profile "$1"
    if [[ "$(iwgetid -r)" -ne "$ESSID" ]]; then
        return 1
    elif ! ip link show dev "$INTERFACE" | fgrep -q "state UP"; then
        return 1
    fi

}

wireless_$1 "$2" "$3"
exit $?

# vim: ft=sh ts=4 et sw=4:

