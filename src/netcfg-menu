#! /bin/bash

. /etc/rc.conf
. /etc/rc.d/functions
. /usr/lib/network/network

# JP: we'll use $STATE_DIR/menu to record what profile is being connected in this way
rm -f "$STATE_DIR/menu"

# Scan all profiles
i=0
while read prof; do
    # if there is a profile called "main", Use as default
    [[ "$prof" = main ]] && DEFAULT=main
    unset DESCRIPTION           # JP: we cant sandbox the sourced profiles, because we need to expose the profiles array
    . "$PROFILE_DIR/$prof"
    profiles[$i]="$prof"
    let i++
    profiles[$i]="$DESCRIPTION"
    let i++
done < <(list_profiles | sort)  # JP: re-use list_profiles instead of duplicating it; avoid subshell we'd get by piping it to the while read...

if [[ ${#profiles} -eq 0 ]]; then
    exit_err "No profiles were found in $PROFILE_DIR"
fi

[[ -n "$NETWORKS_MENU_DEFAULT" ]] && DEFAULT="$NETWORKS_MENU_DEFAULT"
# if no default yet, use the first entry
[[ -z "$DEFAULT" ]] && DEFAULT="${profiles[0]}"
ANSWER=$(mktemp /tmp/menu.XXXXXXXX) || exit 1

# Set timeout
TIMEOUT="${1:-0}"       # JP: equivalent to the block that was here before

# Display Dialog
dialog --timeout "$TIMEOUT" --default-item "$DEFAULT" \
    --menu "Select the network profile you wish to use" \
    13 50 6 "${profiles[@]}" 2> $ANSWER

ret=$?
        
case $ret in
    1) ;; # Cancel - do nothing
    255) # timeout - use default 
        profile_up "$DEFAULT"       # JP: use profile_up and catch $?
        ret=$?
        if [[ $ret -eq 0 ]]; then echo "$DEFAULT" > "$STATE_DIR/menu"; fi
        ;; 
    0)  # User selection
        profile_up "$(cat $ANSWER)"
        ret=$?
        if [[ $ret -eq 0 ]]; then mv $ANSWER "$STATE_DIR/menu"; fi
        ;; 
    *)  # Shouldn't happen
        echo "Abnormal ret code from dialog: $ret" >&2
        ;; 
esac
rm -f $ANSWER     # JP: add -f
exit $ret           # JP: exit with caught $?

# vim: set ts=4 et sw=4:
